.\" Man page generated from reStructuredText.
.
.TH "NONPAREIL" "1" "January 24, 2014" "2.3" "Nonpareil"
.SH NAME
nonpareil \- Nonpareil Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
Nonpareil uses the redundancy of the reads in metagenomic datasets to estimate the average
coverage and predict the amount of sequences that will be required to achieve "nearly complete
coverage".
.SH PREPROCESS THE READS
.sp
Nonpareil expects that the sequencing error is always well below 5%, so we suggest using an expected error cutoff of 1%
(\fIi.e.\fP, Q>20, or 1 error in 100 nucleotides). We recommend to perform this task using \fI\%SolexaQA\fP\&.
.sp
Ideally, the reads should be in FastA format (althought Nonpareil can read FastQ). To transform FastQ into FastA, you
can simply use:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Input: reads.fastq
# Output: reads.fasta
cat reads.fastq | paste \- \- \- \- | awk \(aqBEGIN{FS="\et"}{print ">"substr($1,2)"\en"$2}\(aq > reads.fasta
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Also, if you have paired\-end reads, you should use only one sister read per pair in Nonpareil. If you have them interposed
in the same file, you can separate them using \fI\%FastA.split.pl\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Input: reads.fasta
# Output: reads.1.fa and reads.2.fa
FastA.split.pl reads.fasta reads 2
.ft P
.fi
.UNINDENT
.UNINDENT
.SH REDUNDANCY
.sp
If you have large files (>1Gb) and access to a cluster, take a look at \fBmpi\fP\&.
.SS For the impatient
.sp
Even if you\(aqre in a hurry, taking a look at \fBpreprocess\fP is very important. If you already did, you can simply run:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
nonpareil \-s reads.fa \-b output
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Where \fBreads.fa\fP is the file containing the trimmed single reads, and \fBoutput\fP is the prefix
of the output files to be created.
.SS Mandatory options
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.BI \-s \ <str>
Path to the (input) file containing the sequences.  This is lowercase S.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Common options
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.BI \-f \ <str>
The format of the sequences.  Can be \(aqfasta\(aq or \(aqfastq\(aq.  By default: \(aqfasta\(aq
.TP
.BI \-b \ <str>
Path to the prefix for all the output files.  Replaces the options: \-a, \-C, \-l, and \-o; generating files
with the suffixes .npa, npc, .npl, and .npo, respectively, unless explicitly set.
.TP
.BI \-i \ <num>
Interval between sampling portions.  By default: 0.01.
.TP
.BI \-n \ <int>
Number of sub\-samples to generate per point.  If it is not a multiple of the number of threads (see \-t),
it is rounded to the next (upper) multiple.  By default: 1024.
.TP
.BI \-L \ <num>
Minimum overlapping percentage of the aligned region on the largest sequence. The similarity (see \-S) is
evaluated for the aligned region only.  By default: 50.
.TP
.BI \-X \ <int>
Maximum number of reads to use as query.  This is capital X.  By default, 1,000 reads.
.TP
.BI \-R \ <int>
Maximum RAM usage in Mib.  Ideally this value should be larger than the sequences to analyze (discarding
non\-sequence elements like headers or quality).  This is particularly important when running in multiple
cores (see \-t).  This value is approximated.  By default 1024.
Maximum value in this version: 4194303
.TP
.BI \-t \ <int>
Number of threads.  Highest efficiency when the number of sub\-samples (see \-n) is multiple of the number
of threads.  By default: 2.
.TP
.BI \-v \ <int>
Verbosity level, for debugging purposes.  By default 7.  This is lowercase V.
.TP
.B \-V
Show version information and exit.  This is uppercase V.
.TP
.B \-h
Display this message and exit.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Additional options
.INDENT 0.0
.TP
.B \fBInput/Output\fP
.INDENT 7.0
.TP
.BI \-a \ <str>
Path to the (output) file where all data must be saved.  This report is not created by default.  See the
OUTPUT section.
.TP
.BI \-C \ <str>
Path to the (output) file where the mating vector is to be saved.  This is a capital C.
.TP
.B \-F
Report the sampled portions as a fraction of the library instead of the number of reads.  See \-a, \-o and
the OUTPUT section.
.TP
.BI \-l \ <str>
Path to the (output) file where the log of the run must be saved. By default the log is sent only to the
STDERR.  If set, the log is sent to both the STDERR and the log file.
.TP
.BI \-o \ <str>
Path to the (output) file where summary is to be saved.   By default the summary is sent to stdout (same
behavior as using a dash \(aq\-\(aq).  If an empty string \(aq\(aq is provided, does not produce the summary. See the
OUTPUT section.
.UNINDENT
.TP
.B \fBSampling\fP
.INDENT 7.0
.TP
.BI \-m \ <num>
Minimum value of sampling portion.  By default: 0.
.TP
.BI \-M \ <num>
Maximum value of sampling portion.  By default: 1.
.TP
.BI \-d \ <num>
Take this fraction of the total library every sampling point (logarithmic sampling, not linear).  If set
to zero, logarithmic sub\-sampling is disabled (default). Recommended value: 0.7. EXPERIMENTAL CODE.
.UNINDENT
.TP
.B \fBMating\fP
.INDENT 7.0
.TP
.B \-c
Do not use reverse\-complement.  This is useful for single stranded sequences data (like RNA).  This is a
lowercase C.
.TP
.B \-N
Treat Ns as mismatches.  By default, Ns (unknown nucleotides) match any nucleotide (even another N).
.TP
.BI \-S \ <num>
Similarity threshold to group two reads together.   Reducing this option will increase sensitivity while
increasing running time.  This is uppercase S.
.TP
.BI \-x \ <num>
Probability of taking a sequence into account as query for the construction of the curve.  Higher values
reduce accuracy but increase speed.  This is lower case x.  If set, overides \-X.
.UNINDENT
.TP
.B \fBMisc\fP
.INDENT 7.0
.TP
.B \-A
Autoadjust parameters and re\-run.  Evaluates the results looking for common problems, adjusts parameters
and re\-run the analyses.  THIS IS EXPERIMENTAL CODE.
.TP
.BI \-r \ <int>
Random generator seed.  By default current time.
.UNINDENT
.UNINDENT
.SS Input
.sp
Sequences must be in FastA or FastQ format. See \fBpreprocess\fP\&.
.SS Output
.INDENT 0.0
.TP
.B Redundancy summary: \fB\&.npo\fP file
Tab\-delimited file with six columns. The first column indicates the sequencing effort (in number of reads), and the
remaining columns indicate the summary of the distribution of redundancy (from the replicates, 1,024 by default) at
the given sequencing effort. These five columns are: average redundancy, standard deviation, quartile 1, median
(quartile 2), and quartile 3.
.TP
.B Redundancy values: \fB\&.npa\fP file
Tab\-delimited file with three columns. Similar to the .npo files, it contains information about the redundancy at
each sequencing effort, but it provides ALL the results from the replicates, not only the summary at each point. The
first column indicates the sequencing effort (as a fraction of the dataset), the second column indicates the ID of
the replicate (a number used only to introduce some controlled noise in plots), and the third column indicates the
estimated redundancy value.
.TP
.B Mates distribution: \fB\&.npc\fP file
Raw list with the number of reads in the dataset matching a query read. A set of query reads is randomly drawn by
Nonpareil (1,000 by default), and compared against all reads in the dataset. Each line on this file corresponds to a
query read (the order is not important). We have seen certain correspondance between these numbers and the distribution
of abundances in the community (compared, for example, as rank\-abundance plots), but this file is provided only for
quality\-control purposes and comparisons with other tools.
.TP
.B Log: \fB\&.npl\fP file
A verbose log of internal Nonpareil processing. The number to the left (inside squared brackets) indicate the CPU time
(in minutes). This file also provide quality assessment of the Nonpareil run (automated consistency evaluation). Ideally,
the last line should read "Everything seems correct". Otherwise, it suggests alternative parameters that may improve the
estimation.
.UNINDENT
.SH NONPAREIL CURVES
.sp
The estimation of the \fBredundancy\fP is at the core of Nonpareil, but it\(aqs when those values are transformed
into average coverage that they become comporable across samples, and become useful for project design and sample
evaluation.
.sp
To build Nonpareil curves, you need two things. First, the Nonpareil.R file (you can find it in the \fButils\fP folder
of Nonpareil). Second, the \fB\&.npo\fP file (or \fB\-o\fP value, if you used this option) generated in the estimation of
\fBredundancy\fP\&.
.SS For the impatient
.sp
First, load the package. If you did \fImake install\fP (\fBinstallation\fP), you can simply open \fI\%R\fP and execute:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
library(Nonpareil);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
And you can get help messages using any of:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
?Nonpareil.curve
?Nonpareil.curve.batch
?Nonpareil.legend
?Nonpareil.f
?Nonpareil.antif
?Nonpareil.coverageFactor
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you didn\(aqt install it, you have to load it from the source (although you won\(aqt have the embedded documentation):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
source(\(aqutils/Nonpareil.R\(aq); # Change utils/Nonpareil.R for the actual path to the utils folder
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Now, you can simply execute:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Nonpareil.curve(\(aqoutput.npo\(aq); # Change output.npo to the actual redundancy file.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Nonpareil.curve()
.sp
This function can generate a Nonpareil curve from a \fB\&.npo\fP file. See the documentation of this function inside \fI\%R\fP after
loading the Nonpareil package:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
?Nonpareil.curve
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you didn\(aqt install the Nonpareil package, you can see the documentation from the source:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
tools::Rd2txt(tools::parse_Rd(\(aqutils/nonpareil/man/Nonpareil.curve.Rd\(aq))
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Nonpareil.legend()
.sp
This function creates a legend for the Nonpareil curve(s) in the (active) plot. It\(aqs compatible with single
or multiple calls of \fI\%Nonpareil.curve()\fP (using \fBnew=F\fP in all but the first call) and with
\fI\%Nonpareil.curve.batch()\fP\&. See the documentation inside \fI\%R\fP after loading the Nonpareil package:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
?Nonpareil.legend
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or from the source:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
tools::Rd2txt(tools::parse_Rd(\(aqutils/nonpareil/man/Nonpareil.legend.Rd\(aq))
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Nonpareil.curve.batch()
.sp
This function can generate a plot with several Nonpareil curves from \fB\&.npo\fP files. See the documentation of this
function in \fI\%R\fP after loading the Nonpareil package:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
?Nonpareil.curve.batch
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or from the source:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
tools::Rd2txt(tools::parse_Rd(\(aqutils/nonpareil/man/Nonpareil.curve.batch.Rd\(aq))
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBExample\fP: I find it very convenient to first prepare a table with the samples, something like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# samples.txt
File        Name    R       G       B
# HMP
SRS063417.1.L50.npo Posterior fornix        256     200     200
SRS063287.1.L50.npo Buccal mucosa   256     120     120
SRS062540.1.L50.npo Tongue dorsum   256     3       3
SRS016335.1.L50.npo Stool   200     135     76
SRS015574.1.L50.npo Supragingival plaque    230     100     120
SRS019087.1.L50.npo Anterior nares  220     220     130
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that this table is tab\-delimited, because I find it easier to read, but you can use anything you like (and is
supported by \fI\%R\fP). Next, you can simply type something like this in the \fI\%R\fP console:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
library(Nonpareil); # Or source(\(aqutils/Nonpareil.R\(aq);, if you didn\(aqt "make install"
samples <\- read.table(\(aqsamples.txt\(aq, sep=\(aq\et\(aq, h=T);
attach(samples);
np <\- Nonpareil.curve.batch(File, 50, r=R, g=G, b=B, libnames=Name, modelOnly=TRUE);
Nonpareil.legend(\(aqbottomright\(aq);
detach(samples);
.ft P
.fi
.UNINDENT
.UNINDENT
.SH MPI SUPPORT
.sp
Nonpareil supports MPI (Message Passing Interface) since v2.2. This code is relatively stable, but
it\(aqs not as widely tested as the regular Nonpareil.
.SS Requirements
.sp
You will first need \fI\%OpenMPI\fP in your computer. There are other MPI implementations, but Nonpareil only supports OpenMPI (by now). Once
you have it, you should have at least the C++ compiler (typically \fBmpic++\fP) and the interactive executable (typically \fBmpirun\fP). If
you have the compiler in a non\-standard location (for example, to coexist with mpich), change the value of \fBmpicpp\fP in the \fBglobals.mk\fP
file. Once you are ready, simply run:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cd nonpareil # or wherever you have the nonpareil folder
make nonpareil\-mpi
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
That\(aqs it. Now you should have the \fBnonpareil\-mpi\fP binary, that you can place in a location listed in your \fB$PATH\fP if you want.
.SS Running Nonpareil MPI
.INDENT 0.0
.IP 1. 3
Get your machines ready. If you are familiar with MPI skip directly to #3. If you have your own infrastructure, just make sure they
are MPI\-capable (network, permissions, software, etc.). If you are using a cluster, just request as many machines as you need (see
the resources section below). For example, to request 10 machines with 16 CPUs each in PBS, use \fB\-l nodes=10:ppn=16\fP\&.
.IP 2. 3
Obtain the machine names. Just prepare a raw text file with the list of machines you want to use. If you are using PBS, you can do
this by running:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
cat $PBS_NODEFILE | awk \(aqNR%16==0\(aq > hosts.txt # Change the \(aq16\(aq by the number of CPUs you are using (the value of ppn).
.ft P
.fi
.UNINDENT
.UNINDENT
.IP 3. 3
Run Nonpareil MPI. All you need is to call \fBnonpareil\-mpi\fP with \fBmpirun\fP\&. For example, if you want to use 10 machines, with 16
CPUs each, and the list of machines is in \fBhosts.txt\fP, then run:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
mpirun \-np 10 \-machinefile hosts.txt nonpareil\-mpi \-t 16 \-s path/to/your/sequences.fasta \-b output ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that the options of \fBnonpareil\-mpi\fP are the exact same as for \fBnonpareil\fP\&. Just remember that the value of \fB\-t\fP is the
number of threads \fIper machine\fP, not the total number of CPUs.
.UNINDENT
.SS Resources
.sp
If you are interested on MPI, I\(aqm assuming you have big files, so you may be also concerned about resources allocation.
.INDENT 0.0
.TP
.B How much memory you will need?
In the \fI\%Nonpareil paper\fP (Suppl. Fig. 6) you can see the linear relationship between maximum required RAM and the size of the
dataset. The function is approximately \fBRAM = Size + 2\fP, where \fBRAM\fP and \fBSize\fP are both in Gb. You can use less RAM than
that, and Nonpareil will adapt, but it\(aqll take longer running times. This value is the "maximum required", which means that if you
assign more RAM than that, it won\(aqt make any difference. Now, that value is the total RAM required. That means that if you use the
MPI implementation, you can divide \fBSize\fP by the number of computers you are using, and then apply the function above. For example,
if you have a 50Gb dataset, you will need (maximum) 52Gb (50 + 2) of RAM for the standard implementation of Nonpareil. However, if
you use the MPI version with, for example, 10 machines, you\(aqll need (maximum) 7Gb (50/10 + 2) on each machine.
.TP
.B How many machines you will need?
I don\(aqt have a large benchmarking yet for the MPI version, but at the end it really depends on your resources. If you have more machines,
it will run faster (unless you have a very small dataset) and it will require less memory (as discussed above).
.TP
.B Should I use more machines or more threads?
Again, it depends on your resources. Multi\-threading is (in general) more efficient, because it doesn\(aqt have the overhead of network
communication. That means that you should favor more CPUs over more machines. However, there are some aspects to take into account. One,
as discussed above, is the RAM. More machines = less RAM per machine, while more threads have little impact on RAM usage (actually,
more threads = slighly more RAM). Another catch is the resources availability. It is possible that you have tens of machines for your
exclusive use, but most likely you are actually sharing resources through a cluster architecture. If you ask for 64 processors per node
(assuming you have 64\-core machines) you will probably have to wait in queue for quite some time. If you ask for 4 machines, and 64
processors per node, you will likely be waiting in queue for hours or days. However, the same number of threads (256) can be gathered
by asking for 16 machines, and 16 processors per node. If you do that, you will give the scheduler more flexibility (note that the nodes=4
ppn=64 is a special case of nodes=16 and ppn=16) hence reducing your queue time. You may be asking: can I simply ask for nodes=256 and ppn=1?
Well... you can, but as I said multi\-threading is more efficient than multi\-nodes, so don\(aqt go to the extremes. Also, Nonpareil has three
expensive steps:
.INDENT 7.0
.IP 1. 3
Reading the fasta, which is strictly linear: only one thread is used in only one machine. This process is linear in time with the size
of the input file.
.IP 2. 3
Comparing reads, which is threaded and multi\-node. This is by far the most expensive step, and it is distributed across machines and
across CPUs on each machine. This process is linear in time with the size of the input file.
.IP 3. 3
Subsampling, which is threaded but not multi\-node. This step is not too expensive, and it\(aqs nearly constant time. With default parameters,
it takes about 2 minutes with 64 threads, but it grows if you reduce \fB\-i\fP\&. The time on this step is reduced by more threads (\fB\-t\fP), but
not by more machines.
.UNINDENT
.TP
.B How can I evaluate the performance in pilot runs?
I must say: I rarely do pilot runs. However, I\(aqm often interested on performance for future runs (for example, for other projects). There are
two sources of information that can be handy. One, is the OS itself (or the PBS output file, if you have a good Epiloge configured). For example,
to measure the total RAM used, the total walltime, real time, user time, etc. Another source is the .npl file, which contains a log of the
Nonpareil run (assuming you used the \fB\-b\fP option). The number in squared brackets is the CPU time in minutes. Note that the CPU time here is
only for the "master" machine. That means: the number of CPU minutes added for all the threads in the main machine. Another useful piece of
information is the number of "blocks" used. Ideally, you should have one block per machine; if you have more it means that the RAM assigned
(\fB\-R\fP) was insufficient. You can find it right below the "Designing the blocks scheme..." line. In the ideal scenario (enough RAM), you should
have one Qry block, and as many Sbj blocks as machines (one, if you are not using the MPI implementation). If you have more than that, you could
attain shorter running times by increasing the RAM (\fB\-R\fP).
.UNINDENT
.SH AUTHOR
Luis M Rodriguez-R
.SH COPYRIGHT
2013-2014, Luis M Rodriguez-R
.\" Generated by docutils manpage writer.
.
