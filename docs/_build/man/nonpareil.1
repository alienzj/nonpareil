.\" Man page generated from reStructuredText.
.
.TH "NONPAREIL" "1" "December 23, 2013" "2.2" "Nonpareil"
.SH NAME
nonpareil \- Nonpareil Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
Nonpareil uses the redundancy of the reads in metagenomic datasets to estimate the average
coverage and predict the amount of sequences that will be required to achieve "nearly complete
coverage".
.sp
Contents:
.SH INSTALL NONPAREIL
.SS System requirements
.sp
\fBNonpareil binary\fP: Nonpareil requires a C++ compiler. It has been tested on 64\-bit machines with GCC versions â‰¥4.2.1, running Mac OSX and Red Hat Linux.
.sp
\fBNonpareil MPI\fP: If you want to compile Nonpareil with MPI support, you will need \fI\%OpenMPI\fP (v > 1.4.3 tested). Other implementations of MPI could work, but
are yet untested.
.sp
\fBNonpareil utilities\fP: Requires \fI\%R\fP\&. No additional libraries are necessary.
.SS Compilation
.INDENT 0.0
.IP 1. 3
\fBGet the source\fP
.sp
Clone the repository from \fI\%GitHub\fP:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
git clone git://github.com/lmrodriguezr/nonpareil.git
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you don\(aqt have \fI\%git\fP, you can also download the \fI\%TAR-Ball\fP and unpack it with:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
tar zxvf nonpareil.tar.gz
.ft P
.fi
.UNINDENT
.UNINDENT
.IP 2. 3
\fBCompile and install\fP
.sp
Change directory into the newly created folder, and compile Nonpareil:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
cd nonpareil
make
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you want to compile Nonpareil MPI (see also \fBmpi\fP), just run:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
make nonpareil\-mpi
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you want to make Nonpareil available system\-wide, just copy the generated binary into a folder listed in the \fB$PATH\fP\&. For example:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
sudo cp nonpareil /usr/local/bin/
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SH PREPROCESS THE READS
.sp
Nonpareil expects that the sequencing error is always well below 5%, so we suggest using an expected error cutoff of 1%
(\fIi.e.\fP, Q>20, or 1 error in 100 nucleotides). We recommend to perform this task using \fI\%SolexaQA\fP\&.
.sp
Ideally, the reads should be in FastA format (althought Nonpareil can read FastQ). To transform FastQ into FastA, you
can simply use:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Input: reads.fastq
# Output: reads.fasta
cat reads.fastq | paste \- \- \- \- | awk \(aqBEGIN{FS="\et"}{print ">"substr($1,2)"\en"$2}\(aq > reads.fasta
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Also, if you have paired\-end reads, you should use only one sister read per pair in Nonpareil. If you have them interposed
in the same file, you can separate them using \fI\%FastA.split.pl\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Input: reads.fasta
# Output: reads.1.fa and reads.2.fa
FastA.split.pl reads.fasta reads 2
.ft P
.fi
.UNINDENT
.UNINDENT
.SH REDUNDANCY
.sp
If you have large files (>1Gb) and access to a cluster, take a look at \fBmpi\fP\&.
.SS For the impatient
.sp
Even if you\(aqre in a hurry, taking a look at \fBpreprocess\fP is very important. If you already did, you can simply run:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
nonpareil \-s reads.fa \-b output
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Where \fBreads.fa\fP is the file containing the trimmed single reads, and \fBoutput\fP is the prefix
of the output files to be created.
.SS Mandatory options
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.BI \-s \ <str>
Path to the (input) file containing the sequences.  This is lowercase S.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Additional options
.INDENT 0.0
.TP
.B \fBInput/Output\fP
.INDENT 7.0
.TP
.BI \-a \ <str>
Path to the (output) file where all data must be saved.  This report is not created by default.  See the
OUTPUT section.
.TP
.BI \-b \ <str>
Path to the prefix for all the output files.  Replaces the options: \-a, \-C, \-l, and \-o; generating files
with the suffixes .npa, npc, .npl, and .npo, respectively, unless explicitly set.
.TP
.BI \-C \ <str>
Path to the (output) file where the mating vector is to be saved.  This is a capital C.
.TP
.BI \-f \ <str>
The format of the sequences.  Can be \(aqfasta\(aq or \(aqfastq\(aq.  By default: \(aqfasta\(aq
.TP
.B \-F
Report the sampled portions as a fraction of the library instead of the number of reads.  See \-a, \-o and
the OUTPUT section.
.TP
.BI \-l \ <str>
Path to the (output) file where the log of the run must be saved. By default the log is sent only to the
STDERR.  If set, the log is sent to both the STDERR and the log file.
.TP
.BI \-o \ <str>
Path to the (output) file where summary is to be saved.   By default the summary is sent to stdout (same
behavior as using a dash \(aq\-\(aq).  If an empty string \(aq\(aq is provided, does not produce the summary. See the
OUTPUT section.
.UNINDENT
.TP
.B \fBSampling\fP
.INDENT 7.0
.TP
.BI \-i \ <num>
Interval between sampling portions.  By default: 0.01.
.TP
.BI \-m \ <num>
Minimum value of sampling portion.  By default: 0.
.TP
.BI \-M \ <num>
Maximum value of sampling portion.  By default: 1.
.TP
.BI \-n \ <int>
Number of sub\-samples to generate per point.  If it is not a multiple of the number of threads (see \-t),
it is rounded to the next (upper) multiple.  By default: 1024.
.UNINDENT
.TP
.B \fBMating\fP
.INDENT 7.0
.TP
.B \-c
Do not use reverse\-complement.  This is useful for single stranded sequences data (like RNA).  This is a
lowercase C.
.TP
.BI \-L \ <num>
Minimum overlapping percentage of the aligned region on the largest sequence. The similarity (see \-S) is
evaluated for the aligned region only.  By default: 50.
.TP
.B \-N
Treat Ns as mismatches.  By default, Ns (unknown nucleotides) match any nucleotide (even another N).
.TP
.BI \-S \ <num>
Similarity threshold to group two reads together.   Reducing this option will increase sensitivity while
increasing running time.  By default: 0.97.  This is uppercase S.
.TP
.BI \-x \ <num>
Probability of taking a sequence into account as query for the construction of the curve.  Higher values
reduce accuracy but increase speed.  This is lower case x.  If set, overides \-X.
.TP
.BI \-X \ <int>
Maximum number of reads to use as query.  This is capital X.  By default, 1,000 reads.
.UNINDENT
.TP
.B \fBSystem resources\fP
.INDENT 7.0
.TP
.BI \-R \ <int>
Maximum RAM usage in Mib.  Ideally this value should be larger than the sequences to analyze (discarding
non\-sequence elements like headers or quality).  This is particularly important when running in multiple
cores (see \-t and \-T).  This value is approximated.  By default 1024.
Maximum value in this version: 4194303
.TP
.BI \-t \ <int>
Number of threads.  Highest efficiency when the number of sub\-samples (see \-n) is multiple of the number
of threads.  By default: 2.
.UNINDENT
.TP
.B \fBMisc\fP
.INDENT 7.0
.TP
.B \-A
Autoadjust parameters and re\-run.  Evaluates the results looking for common problems, adjusts parameters
and re\-run the analyses.  THIS IS EXPERIMENTAL CODE.
.TP
.B \-h
Display this message and exit.
.TP
.BI \-r \ <int>
Random generator seed.  By default current time.
.TP
.BI \-v \ <int>
Verbosity level, for debugging purposes.  By default 7.  This is lowercase V.
.TP
.B \-V
Show version information and exit.  This is uppercase V.
.UNINDENT
.UNINDENT
.SS Input
.sp
Sequences must be in FastA or FastQ format. See \fBpreprocess\fP\&.
.SS Output
.INDENT 0.0
.TP
.B Redundancy summary: \fB\&.npo\fP file
Tab\-delimited file with six columns. The first column indicates the sequencing effort (in number of reads), and the
remaining columns indicate the summary of the distribution of redundancy (from the replicates, 1,024 by default) at
the given sequencing effort. These five columns are: average redundancy, standard deviation, quartile 1, median
(quartile 2), and quartile 3.
.TP
.B Redundancy values: \fB\&.npa\fP file
Tab\-delimited file with three columns. Similar to the .npo files, it contains information about the redundancy at
each sequencing effort, but it provides ALL the results from the replicates, not only the summary at each point. The
first column indicates the sequencing effort (as a fraction of the dataset), the second column indicates the ID of
the replicate (a number used only to introduce some controlled noise in plots), and the third column indicates the
estimated redundancy value.
.TP
.B Mates distribution: \fB\&.npc\fP file
Raw list with the number of reads in the dataset matching a query read. A set of query reads is randomly drawn by
Nonpareil (1,000 by default), and compared against all reads in the dataset. Each line on this file corresponds to a
query read (the order is not important). We have seen certain correspondance between these numbers and the distribution
of abundances in the community (compared, for example, as rank\-abundance plots), but this file is provided only for
quality\-control purposes and comparisons with other tools.
.TP
.B Log: \fB\&.npl\fP file
A verbose log of internal Nonpareil processing. The number to the left (inside squared brackets) indicate the CPU time
(in minutes). This file also provide quality assessment of the Nonpareil run (automated consistency evaluation). Ideally,
the last line should read "Everything seems correct". Otherwise, it suggests alternative parameters that may improve the
estimation.
.UNINDENT
.SH NONPAREIL CURVES
.sp
The estimation of the \fBredundancy\fP is at the core of Nonpareil, but it\(aqs when those values are transformed
into average coverage that they become comporable across samples, and become useful for project design and sample
evaluation.
.sp
To build Nonpareil curves, you need two things. First, the Nonpareil.R file (you can find it in the \fButils\fP folder
of Nonpareil). Second, the \fB\&.npo\fP file (or \fB\-o\fP value, if you used this option) generated in the estimation of
\fBredundancy\fP\&.
.SS For the impatient
.sp
You can simply open \fI\%R\fP and execute:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
source(\(aqutils/Nonpareil.R\(aq);
Nonpareil.curve(\(aqoutput.npo\(aq);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Changing \fButils/Nonpareil.R\fP and \fBoutput.npo\fP to point to the actual location of the files.
.SS Nonpareil.curve()
.sp
This function can generate a Nonpareil curve from a \fB\&.npo\fP file. The parameters that this function accepts are:
.INDENT 0.0
.TP
.B file
Path to the \fB\&.npo\fP file, containing the read redundancy.
.TP
.B overlap=NULL
Value of the \fB\-L\fP parameter (in Nonpareil, the default is \fB50\fP). If not set, it tries to find the value in the
\fB\&.npo\fP file (supported in Nonpareil â‰¥2.0), or fails with an error message.
.TP
.B factor=1
Factor by which the number of reads must be multiplied (x\-axis). For example, a factor of 1e\-3 will produce curves
in Kbp (instead of bp). This option should be used when if an "integer overload" is produced, at risk of reducing
the accuracy of the curves.
.TP
.B plotDispersion=NA
Indicates if and how the dispersion of replicates is to be represented. If it\(aqs \fBNA\fP no dispersion is plotted.
Otherwise, it can take the values \fB\(aqsd\(aq\fP: 1 standard deviation around the mean; \fB\(aqci95\(aq\fP: 95% confidence
interval; \fB\(aqci90\(aq\fP: 90% confidence interval; \fB\(aqci50\(aq\fP: 50% confidence interval; \fB\(aqiq\(aq\fP: Inter\-quartile
range.
.TP
.B returnModelValues=FALSE
Indicates if the output should include model.x and model.y, with coordinates used to plot the fitted model.
.TP
.B returnModelParameters=FALSE
Indicates if the a and b parameters of the fitted model should be returned.
.TP
.B xmin=1e3, xmax=10e12
Range to plot in the x\-axis (Sequencing effort).
.TP
.B ymax=1, ymin=1e\-6
Range to plot in the y\-axis (Average coverage).
.TP
.B xlab=NULL,ylab=NULL
Labels of the axes. If \fBNULL\fP, the default values are set Sequencing effort (\fIunits\fP) for the x\-axis, and
Estimated average coverage for the y\-axis.
.TP
.B r=NA,g=NA,b=NA,
Values for the red, green, and blue components of the rgb representation of the curve\(aqs color. If \fBNA\fP, random
values are set. If the numbers are in the range [0,1], they are assumed to be fractions of 1 (as interpreted by
rgb). Otherwise, they are assumed to be fractions of 256 (as represented in most color palettes).
.TP
.B new=TRUE
Indicates if a new canvas must be created. If \fBFALSE\fP, it requires that Nonpareil.curve() was previously called
(so a proper canvas exists already). This is useful to create a single plot with several samples (see also
\fI\%Nonpareil.legend()\fP).
.TP
.B plot=TRUE
Indicates if the curve is to be plotted. If \fBFALSE\fP, no plots are generated, but the estimations are.
.TP
.B libname=NA
Name of the library (to be used in later calls of \fI\%Nonpareil.legend()\fP). If \fBNA\fP the base of the filename
(withouth .npo) is used.
.TP
.B modelOnly=FALSE
If \fBTRUE\fP, prints only the fitted model. It also causes variables related to dispersion and curve to be
ignored, and it produces an empty circle denoting the actual size of the dataset and the estimated average
coverage.
.TP
.B plotModel=TRUE
Indicates whether the fitted model is to be included in the plot. If \fBFALSE\fP, it still fits the model to
find the estimate of sequencing effort, but the curve of the model is not included in the plot.
.TP
.B curve.lwd=2
Line width of the curve (the observed curve, not the fitted model).
.TP
.B curve.alpha=0.4
Transparency of the curve.
.TP
.B model.lwd=1
Line width of the fitted model line.
.TP
.B model.alpha=1
Transparency of the fitted model line.
.TP
.B log=\(aqx\(aq
Use logarithmic scale in the X or Y\-axis (or both).
.TP
.B data.consistency=TRUE
Check consistency of the input data before plotting and fitting the model.
.TP
.B useValue=\(aqmean\(aq
Value of the distribution of replicates to be used as the curve. The fitted model and the estimated coverage
is only meaningful when \fBuseValue=\(aqmean\(aq\fP, but all of the following values are supported to allow visual
inspection of the distribution of replicates: The mean (\fB\(aqmean\(aq\fP) or the median (\fB\(aqmedian\(aq\fP) of the
distribution (\fB\(aqmedian\(aq\fP); the upper (\fB\(aqub\(aq\fP) or the lower (\fB\(aqlb\(aq\fP) bound of the 95% confidence interval
(assuming normality); or the first (\fB\(aqq1\(aq\fP) or the third (\fB\(aqq3\(aq\fP) quartile of the ditribution.
.TP
.B star=95
Value of average coverage (in percentage) to be used as \fIalmost complete covereage\fP\&. Usually this value should
be set to 95 or 99, but other estimations can be useful. For example, setting this value to 60 predicts the
minimum sequencing effort at which an assembly with N50 larger than 200bp can be achieved with (100bp\-long)
Illumina reads.
.TP
.B read.length=101
Length of the reads. This value can be found in the \fB\&.npl\fP file, but other estimation (\fIe.g.\fP, the average
length after trimming) can be used.
.UNINDENT
.sp
\fBValue\fP: A list with the following keys:
.INDENT 0.0
.TP
.B kappa
Redundancy of the dataset, as calculated by Nonpareil.
.TP
.B C
Estimated abundance\-weighted average coverage.
.TP
.B LRstar
Estimated sequecing effort (in bp) required to reach \fBstar\fP average coverage (95%, by default).
.TP
.B LR
Size of the datasets (in bp).
.TP
.B modelR
Pearson\(aqs correlation coeficient between the calculated values and the fitted model.
.UNINDENT
.SS Nonpareil.legend()
.sp
This function creates a legend for the Nonpareil curve(s) in the (active) plot. It\(aqs compatible with single
or multiple calls of \fI\%Nonpareil.curve()\fP (using \fBnew=F\fP in all but the first call) and with
\fI\%Nonpareil.curve.batch()\fP\&. The parameters that this function accepts are:
.INDENT 0.0
.TP
.B x=NULL
Position in the X\-axis. If \fBNULL\fP, it\(aqs located at 75% of the maximum value of X. It can also be set to
any character string supported by xy.coords.
.TP
.B y=.3
Position in the Y\-axis.
.UNINDENT
.INDENT 0.0
.TP
.B \&...
Any other parameter accepted by \fBlegend()\fP is supported, except for \fBfill\fP and \fBlegend\fP\&.
.UNINDENT
.SS Nonpareil.curve.batch()
.sp
This function can generate a plot with several Nonpareil curves from \fB\&.npo\fP files. The parameters that this
function accepts are:
.INDENT 0.0
.TP
.B files
Vector of characters with the paths to the \fB\&.npo\fP files.
.TP
.B overlap=NULL
Value of the \fB\-L\fP parameter (in Nonpareil, the default is \fB50\fP). It can be a number (if all the curves were
generated with the same value) or a vector (in the same order of \fBfiles\fP). See the \fBoverlap\fP value of
\fI\%Nonpareil.curve()\fP\&.
.TP
.B r=NA,g=NA,b=NA
Values of the corresponding \fBr\fP, \fBg\fP, and \fBb\fP in \fI\%Nonpareil.curve()\fP\&. It can be \fBNA\fP (to set random
colors) or vectors of numbers in the same order of \fBfiles\fP\&.
.TP
.B libnames=NA
Vector of names of the libraries (corresponding to \fBlibname\fP in \fI\%Nonpareil.curve()\fP). It must be characters,
not factors.
.TP
.B read.lengths=NA
A vector of numbers indicating the length of the reads (corresponding to \fBread.length\fP in \fI\%Nonpareil.curve()\fP).
If \fBNA\fP, the default is used.
.UNINDENT
.INDENT 0.0
.TP
.B \&...
Any other parameter accepted by \fI\%Nonpareil.curve()\fP is supported.
.UNINDENT
.sp
\fBValue\fP: A dataframe containing the values generated by \fI\%Nonpareil.curve()\fP\&.
.sp
\fBExample\fP: I find it very convenient to first prepare a table with the samples, something like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# samples.txt
File        Name    R       G       B
# HMP
SRS063417.1.L50.npo Posterior fornix        256     200     200
SRS063287.1.L50.npo Buccal mucosa   256     120     120
SRS062540.1.L50.npo Tongue dorsum   256     3       3
SRS016335.1.L50.npo Stool   200     135     76
SRS015574.1.L50.npo Supragingival plaque    230     100     120
SRS019087.1.L50.npo Anterior nares  220     220     130
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that this table is tab\-delimited, because I find it easier to read, but you can use anything you like (and is
supported by \fI\%R\fP). Next, you can simply type something like this in the \fI\%R\fP console:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
source(\(aqutils/Nonpareil.R\(aq);
samples <\- read.table(\(aqsamples.txt\(aq, sep=\(aq\et\(aq, h=T);
attach(samples);
np <\- Nonpareil.curve.batch(File, 50, r=R, g=G, b=B, libnames=Name, modelOnly=TRUE);
Nonpareil.legend(\(aqbottomright\(aq);
detach(samples);
.ft P
.fi
.UNINDENT
.UNINDENT
.SH MPI SUPPORT
.sp
Nonpareil supports MPI (Message Passing Interface) since v2.2. This code is relatively stable, but
it\(aqs not as widely tested as the regular Nonpareil.
.SS Requirements
.sp
You will first need \fI\%OpenMPI\fP in your computer. There are other MPI implementations, but Nonpareil only supports OpenMPI (by now). Once
you have it, you should have at least the C++ compiler (typically \fBmpic++\fP) and the interactive executable (typically \fBmpirun\fP). If
you have the compiler in a non\-standard location (for example, to coexist with mpich), change the value of \fBmpicpp\fP in the \fBglobals.mk\fP
file. Once you are ready, simply run:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cd nonpareil # or wherever you have the nonpareil folder
make nonpareil\-mpi
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
That\(aqs it. Now you should have the \fBnonpareil\-mpi\fP binary, that you can place in a location listed in your \fB$PATH\fP if you want.
.SS Running Nonpareil MPI
.INDENT 0.0
.IP 1. 3
Get your machines ready. If you are familiar with MPI skip directly to #3. If you have your own infrastructure, just make sure they
are MPI\-capable (network, permissions, software, etc.). If you are using a cluster, just request as many machines as you need (see
the resources section below). For example, to request 10 machines with 16 CPUs each in PBS, use \fB\-l nodes=10:ppn=16\fP\&.
.IP 2. 3
Obtain the machine names. Just prepare a raw text file with the list of machines you want to use. If you are using PBS, you can do
this by running:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
cat $PBS_NODEFILE | awk \(aqNR%16==0\(aq > hosts.txt # Change the \(aq16\(aq by the number of CPUs you are using (the value of ppn).
.ft P
.fi
.UNINDENT
.UNINDENT
.IP 3. 3
Run Nonpareil MPI. All you need is to call \fBnonpareil\-mpi\fP with \fBmpirun\fP\&. For example, if you want to use 10 machines, with 16
CPUs each, and the list of machines is in \fBhosts.txt\fP, then run:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
mpirun \-np 10 \-machinefile hosts.txt nonpareil\-mpi \-t 16 \-s path/to/your/sequences.fasta \-b output ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that the options of \fBnonpareil\-mpi\fP are the exact same as for \fBnonpareil\fP\&. Just remember that the value of \fB\-t\fP is the
number of threads \fIper machine\fP, not the total number of CPUs.
.UNINDENT
.SS Resources
.sp
If you are interested on MPI, I\(aqm assuming you have big files, so you may be also concerned about resources allocation.
.INDENT 0.0
.TP
.B How much memory you will need?
In the \fI\%Nonpareil paper\fP (Suppl. Fig. 6) you can see the linear relationship between maximum required RAM and the size of the
dataset. The function is approximately \fBRAM = Size + 2\fP, where \fBRAM\fP and \fBSize\fP are both in Gb. You can use less RAM than
that, and Nonpareil will adapt, but it\(aqll take longer running times. This value is the "maximum required", which means that if you
assign more RAM than that, it won\(aqt make any difference. Now, that value is the total RAM required. That means that if you use the
MPI implementation, you can divide \fBSize\fP by the number of computers you are using, and then apply the function above. For example,
if you have a 50Gb dataset, you will need (maximum) 52Gb (50 + 2) of RAM for the standard implementation of Nonpareil. However, if
you use the MPI version with, for example, 10 machines, you\(aqll need (maximum) 7Gb (50/10 + 2) on each machine.
.TP
.B How many machines you will need?
I don\(aqt have a large benchmarking yet for the MPI version, but at the end it really depends on your resources. If you have more machines,
it will run faster (unless you have a very small dataset) and it will require less memory (as discussed above).
.TP
.B Should I use more machines or more threads?
Again, it depends on your resources. Multi\-threading is (in general) more efficient, because it doesn\(aqt have the overhead of network
communication. That means that you should favor more CPUs over more machines. However, there are some aspects to take into account. One,
as discussed above, is the RAM. More machines = less RAM per machine, while more threads have little impact on RAM usage (actually,
more threads = slighly more RAM). Another catch is the resources availability. It is possible that you have tens of machines for your
exclusive use, but most likely you are actually sharing resources through a cluster architecture. If you ask for 64 processors per node
(assuming you have 64\-core machines) you will probably have to wait in queue for quite some time. If you ask for 4 machines, and 64
processors per node, you will likely be waiting in queue for hours or days. However, the same number of threads (256) can be gathered
by asking for 16 machines, and 16 processors per node. If you do that, you will give the scheduler more flexibility (note that the nodes=4
ppn=64 is a special case of nodes=16 and ppn=16) hence reducing your queue time. You may be asking: can I simply ask for nodes=256 and ppn=1?
Well... you can, but as I said multi\-threading is more efficient than multi\-nodes, so don\(aqt go to the extremes. Also, Nonpareil has three
expensive steps:
.INDENT 7.0
.IP 1. 3
Reading the fasta, which is strictly linear: only one thread is used in only one machine. This process is linear in time with the size
of the input file.
.IP 2. 3
Comparing reads, which is threaded and multi\-node. This is by far the most expensive step, and it is distributed across machines and
across CPUs on each machine. This process is linear in time with the size of the input file.
.IP 3. 3
Subsampling, which is threaded but not multi\-node. This step is not too expensive, and it\(aqs nearly constant time. With default parameters,
it takes about 2 minutes with 64 threads, but it grows if you reduce \fB\-i\fP\&. The time on this step is reduced by more threads (\fB\-t\fP), but
not by more machines.
.UNINDENT
.TP
.B How can I evaluate the performance in pilot runs?
I must say: I rarely do pilot runs. However, I\(aqm often interested on performance for future runs (for example, for other projects). There are
two sources of information that can be handy. One, is the OS itself (or the PBS output file, if you have a good Epiloge configured). For example,
to measure the total RAM used, the total walltime, real time, user time, etc. Another source is the .npl file, which contains a log of the
Nonpareil run (assuming you used the \fB\-b\fP option). The number in squared brackets is the CPU time in minutes. Note that the CPU time here is
only for the "master" machine. That means: the number of CPU minutes added for all the threads in the main machine. Another useful piece of
information is the number of "blocks" used. Ideally, you should have one block per machine; if you have more it means that the RAM assigned
(\fB\-R\fP) was insufficient. You can find it right below the "Designing the blocks scheme..." line. In the ideal scenario (enough RAM), you should
have one Qry block, and as many Sbj blocks as machines (one, if you are not using the MPI implementation). If you have more than that, you could
attain shorter running times by increasing the RAM (\fB\-R\fP).
.UNINDENT
.SH AUTHOR
Luis M Rodriguez-R
.SH COPYRIGHT
2013, Luis M Rodriguez-R
.\" Generated by docutils manpage writer.
.
